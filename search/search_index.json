{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Liquigraph \u2693 Database refactoring automation for Neo4j , the leading graph database. About \u2693 Liquigraph is a database refactoring tool. It helps you maintain your Neo4j database state by defining and incrementally executing migrations. This project is heavily inspired by Liqui base . Users will find many similarities in the terms that Liquigraph and Liquibase use. Versions \u2693 Liquigraph versions are aligned with Neo4j major versions. Liquigraph 1.x has never been released as a generally available version. Its documentation has been removed entirely. Liquigraph 2.x (for Neo4j 2.x) is available but should not be used anymore. Only the Liquigraph 3.x (for Neo4j 3.x) and 4.x (for Neo4j 4.x) are actively maintained. Info The following versions of Neo4j are currently available: 3.5.x: which is a LTS release 4.x: which includes the latest features If you are using an older Neo4j version, make sure to upgrade first!","title":"Home"},{"location":"#liquigraph","text":"Database refactoring automation for Neo4j , the leading graph database.","title":"Liquigraph"},{"location":"#about","text":"Liquigraph is a database refactoring tool. It helps you maintain your Neo4j database state by defining and incrementally executing migrations. This project is heavily inspired by Liqui base . Users will find many similarities in the terms that Liquigraph and Liquibase use.","title":"About"},{"location":"#versions","text":"Liquigraph versions are aligned with Neo4j major versions. Liquigraph 1.x has never been released as a generally available version. Its documentation has been removed entirely. Liquigraph 2.x (for Neo4j 2.x) is available but should not be used anymore. Only the Liquigraph 3.x (for Neo4j 3.x) and 4.x (for Neo4j 4.x) are actively maintained. Info The following versions of Neo4j are currently available: 3.5.x: which is a LTS release 4.x: which includes the latest features If you are using an older Neo4j version, make sure to upgrade first!","title":"Versions"},{"location":"2.x/","text":"Liquigraph 2.x (Archive) \u2693 Caution Liquigraph 2.x is not maintained anymore. Please upgrade to the latest version. Crash Course \u2693 Liquigraph executes migrations defined in a single change log . These migrations are actually called change sets . Each change set must define at least 1 migration query in the Cypher query language . Change sets are immutable (i.e. not allowed to change) and incremental (i.e. executed only once) by default. Liquigraph persists the executed change sets in the target graph database every time it runs. See the detailed section to understand the Liquigraph model in more details. The Migration File \u2693 Open your favourite editor and define a change log with two change sets as follows: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation= \"https://www.liquigraph.org/schema/1.0/liquigraph.xsd\" > <changeset id= \"hello-world\" author= \"you\" > <query> CREATE (n:Sentence {text:'Hello monde!'}) RETURN n </query> </changeset> <changeset id= \"hello-world-fixed\" author= \"you\" > <query> MATCH (n:Sentence {text:'Hello monde!'}) SET n.text='Hello world!' RETURN n </query> </changeset> </changelog> These migrations can be run using the Java API , via your Maven project or simply using the command line . Choose the way that fits your project. Java API \u2693 Save the migration file at ${your_project}/src/main/resources/changelog.xml . Then, include Liquigraph in your pom.xml : <dependency> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-core </artifactId> <version> 2.0.3 </version> </dependency> If you want to consume a SNAPSHOT version, you need to add the following to your POM: <repositories> <repository> <id> ossrh </id> <name> Sonatype Snapshots </name> <url> https://oss.sonatype.org/content/repositories/snapshots </url> <snapshots> <enabled> true </enabled> </snapshots> <releases> <enabled> false </enabled> </releases> </repository> </repositories> Finally, running the migrations can be done as follows: import org.liquigraph.core.api.Liquigraph ; import org.liquigraph.core.configuration.Configuration ; import org.liquigraph.core.configuration.ConfigurationBuilder ; // [...] Configuration configuration = new ConfigurationBuilder () . withMasterChangelogLocation ( \"changelog.xml\" ) . withUri ( \"jdbc:neo4j:http://localhost:7474\" ) . withRunMode () . build (); Liquigraph liquigraph = new Liquigraph (); liquigraph . runMigrations ( configuration ); If you want to simulate (also known as \\\"dry-run\\\") your migrations without actually running them, replace withRunMode() by withDryRunMode(Paths.get(outputDirectory)) , where outputDirectory specifies the path of the directory where output.cypher will be written in. ::: The Maven way \u2693 Save the migration file at ${your_project}/src/main/resources/changelog.xml (see the above section to learn how to consume SNAPSHOT versions):. Then, include Liquigraph plugin in your pom.xml : <plugin> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-maven-plugin </artifactId> <version> 2.0.3 </version> <configuration> <changelog> changelog.xml </changelog> <!-- classpath location --> <jdbcUri> jdbc:neo4j:http://localhost:7474 </jdbcUri> </configuration> <executions> <execution> <id> run-migrations </id> <goals> <goal> dry-run </goal> <goal> run </goal> </goals> </execution> </executions> </plugin> And finally, run: $> mvn clean package Highway to shell \u2693 Save the migration file at ${your_project}/migrations/changelog.xml . Tip Homebrew users, skip the following installation steps altogether. Specific instructions are here . Prerequisites \u2693 make sure at least JRE 8 is set up and java is included in your path decompress Liquigraph zip , tar.gz or tar.bz2 in LIQUIGRAPH_DIR include LIQUIGRAPH_DIR/liquigraph-cli/ to your PATH Unix users: make sure LIQUIGRAPH_DIR/liquigraph-cli/liquigraph.sh is executable You can now check your installation by executing the following command (reminder to non-Unix users: replace .sh with .bat ): Running Liquigraph \u2693 Interactive mode \u2693 $> cd LIQUIGRAPH_DIR/liquigraph-cli $> ./liquigraph.sh --help A description should be displayed. Then, simulate the changes (replace /tmp with whatever floats your boat): $> ./liquigraph.sh --changelog \" ${ your_project } /migrations/changelog.xml\" \\ --username neo4j \\ --password \\ # leave empty (password prompt will appear) --graph-db-uri jdbc:neo4j:http://localhost:7474/ \\ --dry-run-output-directory /tmp # check contents $> less /tmp/output.cypher And finally, run: $> ./liquigraph.sh --changelog \" ${ your_project } /migrations/changelog.xml\" \\ --username neo4j \\ --password \\ # leave empty (password prompt will appear) --graph-db-uri jdbc:neo4j:http://localhost:7474/ Non-interactive mode \u2693 The above methods will prompt for your Neo4j password. If you wish to run liquigraph without password prompt (i.e. non interactively): $> touch my_password.txt # update mypassword.txt to contain your password and chmod appropriately $> ./liquigraph.sh --changelog \" ${ your_project } /migrations/changelog.xml\" \\ --username neo4j \\ --graph-db-uri jdbc:neo4j:http://localhost:7474/ \\ --password < my_password.txt Detailed section \u2693 Supported JDBC urls \u2693 http: The URL pattern is: jdbc:neo4j:http://<host>:<port>/ For instance: jdbc:neo4j:http://localhost:7474 https: The URL pattern is: jdbc:neo4j:https://<host>:<port>/ For instance: jdbc:neo4j:https://localhost:7663 bolt: The URL pattern is: jdbc:neo4j:bolt://<host>:<port>/ For instance: jdbc:neo4j:bolt://localhost:7687 Definitions \u2693 Change log \u2693 A Liquigraph change log defines a set of migrations (change sets) to be performed. There can be only one change log as entry point per project. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns= \"https://liquigraph.github.io/schema/1.0/liquigraph.xsd\" > <!-- import \"sub-change logs\"--> <import resource= \"version_1/sub_changelog.xml\" /> <import resource= \"version_2/sub_changelog.xml\" /> <!-- and/or define directly change sets--> <changeset [...] /> <!-- [...] --> </changelog> Both sub_changelog.xml files could import change logs and/or define changeset elements. Their root element is also changelog . Change set \u2693 A Liquigraph change set describes one or more create or update statement. These statements must be written in Cypher Query Language and are wrapped in a single transaction (1 transaction per change set). A change set can be run only once (incremental) and cannot be altered (immutable) against the same graph database instance, by default. Finally, a change set is uniquely identified within the change log by its mandatory ID and author attributes. <changeset id= \"unique_identifier\" author= \"team_or_individual_name\" > <!-- 1 to n queries: all executed in 1 transaction --> <query> CREATE (m:MyAwesomeNode) RETURN m </query> <query> CREATE (m:MyOtherAwesomeNode) RETURN m </query> </changeset> Both sub_changelog.xml files could import change logs and/or define changeset elements. Execution context \u2693 An execution context is a simple string, defined at change set level. A change set can have 0, 1 or more execution contexts (in the latter case, they\\'re comma-separated). For instance: <changeset id= \"hello-world\" author= \"you\" contexts= \"foo,bar\" > <query> CREATE (n:Sentence {text:'Hello monde!'}) RETURN n </query> </changeset> If no execution contexts are specified at runtime, all change sets will match.\\ If one or more execution contexts are specified at runtime, change sets will be selected: if they do not declare any execution contexts or one of their declared contexts match one of the runtime contexts Change set immutability \u2693 As previously mentioned, Liquigraph change sets are immutable by default (an error will be thrown if they have been altered). That said, there may be situations where change sets should be run whenever their contents have changed. When a change occurs, the change set computed checksum will change and Liquigraph will execute the changeeset queries. To allow such a scenario, you just need to add an extra attribute to the change set element: <changeset id= \"hello-world\" author= \"you\" run-on-change= \"true\" > <query> CREATE (n:Sentence {text:'Hello monde!'}) RETURN n </query> </changeset> Change set incrementality \u2693 Liquigraph change sets are incremental by default (they will be executed only once). That said, there may be situations where change sets should be run at every execution. To achieve this, you just need to define one extra attribute: <changeset id= \"hello-world\" author= \"you\" run-always= \"true\" > <query> CREATE (n:Sentence {text:'Hello monde!'}) RETURN n </query> </changeset> Combining mutability and non-incrementality \u2693 A mutable change set ( run-on-change=true ) is not going to run unless its content change.\\ Similarly, a non-incremental change set ( run-always=\"true\" ) will always run as long as it never changes (else an error would occur, change sets are immutable by default).\\ If you need to run a change set all the time and allow its content to change, then you need to combine both attributes. <changeset id= \"hello-world\" author= \"you\" run-always= \"true\" run-on-change= \"true\" > <query> CREATE (n:Sentence {text:'Hello monde!'}) RETURN n </query> </changeset> Change set precondition \u2693 Change set preconditions act like guards. They make sure that the change set queries will be executed if and only if the precondition is met. A precondition can be simple (1 Cypher query) or compound (with boolean AND/OR operators). In any case, each of the subqueries/the simple query has to return exactly one column named result of type boolean (true|false). Note that a precondition cannot modify the database itself: all changes will be rolled back. If the precondition fails, an error policy has to be selected amongst the following choices: CONTINUE : ignores the precondition error and skips the associated change set execution MARK_AS_EXECUTED : ignores the precondition error and marks the change set as executed (without actually executing it) FAIL : halts the whole execution, reporting the precondition error Here is a basic precondition example (you are right: this is the dumbest precondition ever): <changeset id= \"hello-world\" author= \"you\" > <precondition if-not-met= \"MARK_AS_EXECUTED\" > <query> RETURN true AS result </query> </precondition> <query> CREATE (n:Sentence {text:'Hello monde!'}) RETURN n </query> </changeset> Here comes a slightly more complicated example: <changeset id= \"contest-winner-selection\" author= \"futuroscope-engineering\" > <precondition if-not-met= \"FAIL\" > <or> <and> <query> MATCH (p:User {twitter:'@fbiville'}) RETURN NOT (p.underAge) AS result </query> <query> <![CDATA[MATCH (p:User {twitter:'@fbiville'}) OPTIONAL MATCH (p)-[:SUFFERS_FROM]->(d:NEURO_DISORDER {name:'photosensitive epilepsy'}) RETURN (d IS NULL) AS result]]> </query> </and> <query> <![CDATA[MATCH (p:User {twitter:'@fbiville'}) OPTIONAL MATCH (p)<-[:HAS_PARENTAL_CONTROL]-(parent:User) RETURN NOT (parent IS NULL) AS RESULT]]> </query> </or> </precondition> <query> <![CDATA[MATCH (p:User {twitter:'@fbiville'}) CREATE (p)-[:IS_OFFERED_FREE_PASS_TO]->(:Location {name:'Futuroscope'})]]> </query> </changeset> Change set postcondition \u2693 Change set postconditions allow a single change set to be applied as many times as necessary to complete the migration, by repeating the change set queries as long as the postcondition is met. A postcondition can be simple (1 Cypher query) or compound (with boolean AND/OR operators). In any case, each of the subqueries/the simple query has to return exactly one column named result of type boolean (true|false). Note that a postcondition cannot modify the database itself: all changes will be rolled back. Once the postcondition returns false, the change set is considered complete. A repeatable change set can be used to perform a migration on a large database without risking an OutOfMemoryError because of the large number of nodes or relationships impacted, by splitting the migration into smaller batches. Here is a postcondition example, deleting all relationships in the database by batches of 10: <changeset id= \"delete-relationships\" author= \"you\" > <query> <![CDATA[MATCH ()-[r]->() WITH r LIMIT 10 DELETE r]]> </query> <postcondition> <query> <![CDATA[OPTIONAL MATCH ()-[r]->() WITH r LIMIT 1 RETURN (r IS NOT NULL) AS result]]> </query> </postcondition> </changeset>","title":"[archive] 2.x manual"},{"location":"2.x/#liquigraph-2x-archive","text":"Caution Liquigraph 2.x is not maintained anymore. Please upgrade to the latest version.","title":"Liquigraph 2.x (Archive)"},{"location":"2.x/#crash-course","text":"Liquigraph executes migrations defined in a single change log . These migrations are actually called change sets . Each change set must define at least 1 migration query in the Cypher query language . Change sets are immutable (i.e. not allowed to change) and incremental (i.e. executed only once) by default. Liquigraph persists the executed change sets in the target graph database every time it runs. See the detailed section to understand the Liquigraph model in more details.","title":"Crash Course"},{"location":"2.x/#the-migration-file","text":"Open your favourite editor and define a change log with two change sets as follows: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation= \"https://www.liquigraph.org/schema/1.0/liquigraph.xsd\" > <changeset id= \"hello-world\" author= \"you\" > <query> CREATE (n:Sentence {text:'Hello monde!'}) RETURN n </query> </changeset> <changeset id= \"hello-world-fixed\" author= \"you\" > <query> MATCH (n:Sentence {text:'Hello monde!'}) SET n.text='Hello world!' RETURN n </query> </changeset> </changelog> These migrations can be run using the Java API , via your Maven project or simply using the command line . Choose the way that fits your project.","title":"The Migration File"},{"location":"2.x/#java-api","text":"Save the migration file at ${your_project}/src/main/resources/changelog.xml . Then, include Liquigraph in your pom.xml : <dependency> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-core </artifactId> <version> 2.0.3 </version> </dependency> If you want to consume a SNAPSHOT version, you need to add the following to your POM: <repositories> <repository> <id> ossrh </id> <name> Sonatype Snapshots </name> <url> https://oss.sonatype.org/content/repositories/snapshots </url> <snapshots> <enabled> true </enabled> </snapshots> <releases> <enabled> false </enabled> </releases> </repository> </repositories> Finally, running the migrations can be done as follows: import org.liquigraph.core.api.Liquigraph ; import org.liquigraph.core.configuration.Configuration ; import org.liquigraph.core.configuration.ConfigurationBuilder ; // [...] Configuration configuration = new ConfigurationBuilder () . withMasterChangelogLocation ( \"changelog.xml\" ) . withUri ( \"jdbc:neo4j:http://localhost:7474\" ) . withRunMode () . build (); Liquigraph liquigraph = new Liquigraph (); liquigraph . runMigrations ( configuration ); If you want to simulate (also known as \\\"dry-run\\\") your migrations without actually running them, replace withRunMode() by withDryRunMode(Paths.get(outputDirectory)) , where outputDirectory specifies the path of the directory where output.cypher will be written in. :::","title":"Java API"},{"location":"2.x/#the-maven-way","text":"Save the migration file at ${your_project}/src/main/resources/changelog.xml (see the above section to learn how to consume SNAPSHOT versions):. Then, include Liquigraph plugin in your pom.xml : <plugin> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-maven-plugin </artifactId> <version> 2.0.3 </version> <configuration> <changelog> changelog.xml </changelog> <!-- classpath location --> <jdbcUri> jdbc:neo4j:http://localhost:7474 </jdbcUri> </configuration> <executions> <execution> <id> run-migrations </id> <goals> <goal> dry-run </goal> <goal> run </goal> </goals> </execution> </executions> </plugin> And finally, run: $> mvn clean package","title":"The Maven way"},{"location":"2.x/#highway-to-shell","text":"Save the migration file at ${your_project}/migrations/changelog.xml . Tip Homebrew users, skip the following installation steps altogether. Specific instructions are here .","title":"Highway to shell"},{"location":"2.x/#prerequisites","text":"make sure at least JRE 8 is set up and java is included in your path decompress Liquigraph zip , tar.gz or tar.bz2 in LIQUIGRAPH_DIR include LIQUIGRAPH_DIR/liquigraph-cli/ to your PATH Unix users: make sure LIQUIGRAPH_DIR/liquigraph-cli/liquigraph.sh is executable You can now check your installation by executing the following command (reminder to non-Unix users: replace .sh with .bat ):","title":"Prerequisites"},{"location":"2.x/#running-liquigraph","text":"","title":"Running Liquigraph"},{"location":"2.x/#interactive-mode","text":"$> cd LIQUIGRAPH_DIR/liquigraph-cli $> ./liquigraph.sh --help A description should be displayed. Then, simulate the changes (replace /tmp with whatever floats your boat): $> ./liquigraph.sh --changelog \" ${ your_project } /migrations/changelog.xml\" \\ --username neo4j \\ --password \\ # leave empty (password prompt will appear) --graph-db-uri jdbc:neo4j:http://localhost:7474/ \\ --dry-run-output-directory /tmp # check contents $> less /tmp/output.cypher And finally, run: $> ./liquigraph.sh --changelog \" ${ your_project } /migrations/changelog.xml\" \\ --username neo4j \\ --password \\ # leave empty (password prompt will appear) --graph-db-uri jdbc:neo4j:http://localhost:7474/","title":"Interactive mode"},{"location":"2.x/#non-interactive-mode","text":"The above methods will prompt for your Neo4j password. If you wish to run liquigraph without password prompt (i.e. non interactively): $> touch my_password.txt # update mypassword.txt to contain your password and chmod appropriately $> ./liquigraph.sh --changelog \" ${ your_project } /migrations/changelog.xml\" \\ --username neo4j \\ --graph-db-uri jdbc:neo4j:http://localhost:7474/ \\ --password < my_password.txt","title":"Non-interactive mode"},{"location":"2.x/#detailed-section","text":"","title":"Detailed section"},{"location":"2.x/#supported-jdbc-urls","text":"http: The URL pattern is: jdbc:neo4j:http://<host>:<port>/ For instance: jdbc:neo4j:http://localhost:7474 https: The URL pattern is: jdbc:neo4j:https://<host>:<port>/ For instance: jdbc:neo4j:https://localhost:7663 bolt: The URL pattern is: jdbc:neo4j:bolt://<host>:<port>/ For instance: jdbc:neo4j:bolt://localhost:7687","title":"Supported JDBC urls"},{"location":"2.x/#definitions","text":"","title":"Definitions"},{"location":"2.x/#change-log","text":"A Liquigraph change log defines a set of migrations (change sets) to be performed. There can be only one change log as entry point per project. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns= \"https://liquigraph.github.io/schema/1.0/liquigraph.xsd\" > <!-- import \"sub-change logs\"--> <import resource= \"version_1/sub_changelog.xml\" /> <import resource= \"version_2/sub_changelog.xml\" /> <!-- and/or define directly change sets--> <changeset [...] /> <!-- [...] --> </changelog> Both sub_changelog.xml files could import change logs and/or define changeset elements. Their root element is also changelog .","title":"Change log"},{"location":"2.x/#change-set","text":"A Liquigraph change set describes one or more create or update statement. These statements must be written in Cypher Query Language and are wrapped in a single transaction (1 transaction per change set). A change set can be run only once (incremental) and cannot be altered (immutable) against the same graph database instance, by default. Finally, a change set is uniquely identified within the change log by its mandatory ID and author attributes. <changeset id= \"unique_identifier\" author= \"team_or_individual_name\" > <!-- 1 to n queries: all executed in 1 transaction --> <query> CREATE (m:MyAwesomeNode) RETURN m </query> <query> CREATE (m:MyOtherAwesomeNode) RETURN m </query> </changeset> Both sub_changelog.xml files could import change logs and/or define changeset elements.","title":"Change set"},{"location":"2.x/#execution-context","text":"An execution context is a simple string, defined at change set level. A change set can have 0, 1 or more execution contexts (in the latter case, they\\'re comma-separated). For instance: <changeset id= \"hello-world\" author= \"you\" contexts= \"foo,bar\" > <query> CREATE (n:Sentence {text:'Hello monde!'}) RETURN n </query> </changeset> If no execution contexts are specified at runtime, all change sets will match.\\ If one or more execution contexts are specified at runtime, change sets will be selected: if they do not declare any execution contexts or one of their declared contexts match one of the runtime contexts","title":"Execution context"},{"location":"2.x/#change-set-immutability","text":"As previously mentioned, Liquigraph change sets are immutable by default (an error will be thrown if they have been altered). That said, there may be situations where change sets should be run whenever their contents have changed. When a change occurs, the change set computed checksum will change and Liquigraph will execute the changeeset queries. To allow such a scenario, you just need to add an extra attribute to the change set element: <changeset id= \"hello-world\" author= \"you\" run-on-change= \"true\" > <query> CREATE (n:Sentence {text:'Hello monde!'}) RETURN n </query> </changeset>","title":"Change set immutability"},{"location":"2.x/#change-set-incrementality","text":"Liquigraph change sets are incremental by default (they will be executed only once). That said, there may be situations where change sets should be run at every execution. To achieve this, you just need to define one extra attribute: <changeset id= \"hello-world\" author= \"you\" run-always= \"true\" > <query> CREATE (n:Sentence {text:'Hello monde!'}) RETURN n </query> </changeset>","title":"Change set incrementality"},{"location":"2.x/#combining-mutability-and-non-incrementality","text":"A mutable change set ( run-on-change=true ) is not going to run unless its content change.\\ Similarly, a non-incremental change set ( run-always=\"true\" ) will always run as long as it never changes (else an error would occur, change sets are immutable by default).\\ If you need to run a change set all the time and allow its content to change, then you need to combine both attributes. <changeset id= \"hello-world\" author= \"you\" run-always= \"true\" run-on-change= \"true\" > <query> CREATE (n:Sentence {text:'Hello monde!'}) RETURN n </query> </changeset>","title":"Combining mutability and non-incrementality"},{"location":"2.x/#change-set-precondition","text":"Change set preconditions act like guards. They make sure that the change set queries will be executed if and only if the precondition is met. A precondition can be simple (1 Cypher query) or compound (with boolean AND/OR operators). In any case, each of the subqueries/the simple query has to return exactly one column named result of type boolean (true|false). Note that a precondition cannot modify the database itself: all changes will be rolled back. If the precondition fails, an error policy has to be selected amongst the following choices: CONTINUE : ignores the precondition error and skips the associated change set execution MARK_AS_EXECUTED : ignores the precondition error and marks the change set as executed (without actually executing it) FAIL : halts the whole execution, reporting the precondition error Here is a basic precondition example (you are right: this is the dumbest precondition ever): <changeset id= \"hello-world\" author= \"you\" > <precondition if-not-met= \"MARK_AS_EXECUTED\" > <query> RETURN true AS result </query> </precondition> <query> CREATE (n:Sentence {text:'Hello monde!'}) RETURN n </query> </changeset> Here comes a slightly more complicated example: <changeset id= \"contest-winner-selection\" author= \"futuroscope-engineering\" > <precondition if-not-met= \"FAIL\" > <or> <and> <query> MATCH (p:User {twitter:'@fbiville'}) RETURN NOT (p.underAge) AS result </query> <query> <![CDATA[MATCH (p:User {twitter:'@fbiville'}) OPTIONAL MATCH (p)-[:SUFFERS_FROM]->(d:NEURO_DISORDER {name:'photosensitive epilepsy'}) RETURN (d IS NULL) AS result]]> </query> </and> <query> <![CDATA[MATCH (p:User {twitter:'@fbiville'}) OPTIONAL MATCH (p)<-[:HAS_PARENTAL_CONTROL]-(parent:User) RETURN NOT (parent IS NULL) AS RESULT]]> </query> </or> </precondition> <query> <![CDATA[MATCH (p:User {twitter:'@fbiville'}) CREATE (p)-[:IS_OFFERED_FREE_PASS_TO]->(:Location {name:'Futuroscope'})]]> </query> </changeset>","title":"Change set precondition"},{"location":"2.x/#change-set-postcondition","text":"Change set postconditions allow a single change set to be applied as many times as necessary to complete the migration, by repeating the change set queries as long as the postcondition is met. A postcondition can be simple (1 Cypher query) or compound (with boolean AND/OR operators). In any case, each of the subqueries/the simple query has to return exactly one column named result of type boolean (true|false). Note that a postcondition cannot modify the database itself: all changes will be rolled back. Once the postcondition returns false, the change set is considered complete. A repeatable change set can be used to perform a migration on a large database without risking an OutOfMemoryError because of the large number of nodes or relationships impacted, by splitting the migration into smaller batches. Here is a postcondition example, deleting all relationships in the database by batches of 10: <changeset id= \"delete-relationships\" author= \"you\" > <query> <![CDATA[MATCH ()-[r]->() WITH r LIMIT 10 DELETE r]]> </query> <postcondition> <query> <![CDATA[OPTIONAL MATCH ()-[r]->() WITH r LIMIT 1 RETURN (r IS NOT NULL) AS result]]> </query> </postcondition> </changeset>","title":"Change set postcondition"},{"location":"download/","text":"Download Liquigraph \u2693 CLI \u2693 For Homebrew users (Mac OS ) \u2693 Liquigraph is part of the standard recipes of Homebrew . You just have to run: brew install liquigraph Regular download (Unix & Windows) \u2693 Liquigraph 4.x liquigraph-cli.zip liquigraph-cli.tar.gz liquigraph-cli.tar.bz2 Liquigraph 3.x liquigraph-cli.zip liquigraph-cli.tar.gz liquigraph-cli.tar.bz2 These archives contain two scripts: liquigraph-cli.sh for Unix users liquigraph-cli.bat for Windows users JVM \u2693 The following artefacts are available through Maven Central. Info If you want to try a development version (a.k.a. a SNAPSHOT version), you do not need to build from sources. You can configure your build with a custom repository: <repositories> <repository> <id> ossrh </id> <name> Sonatype Snapshots </name> <url> https://oss.sonatype.org/content/repositories/snapshots </url> <snapshots> <enabled> true </enabled> </snapshots> <releases> <enabled> false </enabled> </releases> </repository> </repositories> Maven plugin \u2693 Liquigraph 4.x <plugin> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-maven-plugin </artifactId> <version> 4.0.3 </version> <configuration> <changelog> changelog.xml </changelog> <!-- classpath location --> <jdbcUri> jdbc:neo4j:bolt://localhost </jdbcUri> </configuration> <executions> <execution> <id> run-migrations </id> <goals> <goal> dry-run </goal> <goal> run </goal> </goals> </execution> </executions> </plugin> Liquigraph 3.x <plugin> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-maven-plugin </artifactId> <version> 3.1.2 </version> <configuration> <changelog> changelog.xml </changelog> <!-- classpath location --> <jdbcUri> jdbc:neo4j:bolt://localhost </jdbcUri> </configuration> <executions> <execution> <id> run-migrations </id> <goals> <goal> dry-run </goal> <goal> run </goal> </goals> </execution> </executions> </plugin> Spring Boot starter \u2693 Liquigraph 4.x <dependency> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-spring-boot-starter </artifactId> <version> 4.0.3 </version> </dependency> Liquigraph 3.x <dependency> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-spring-boot-starter </artifactId> <version> 3.1.2 </version> </dependency> Liquigraph Core \u2693 Caution Liquigraph is better used through the CLI , Maven plugin or Spring Boot starter. If you want to build an integration, please file an issue and let's discuss! Liquigraph 4.x <dependency> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-core </artifactId> <version> 4.0.3 </version> </dependency> Liquigraph 3.x <dependency> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-core </artifactId> <version> 3.1.2 </version> </dependency>","title":"Download"},{"location":"download/#download-liquigraph","text":"","title":"Download Liquigraph"},{"location":"download/#cli","text":"","title":"CLI"},{"location":"download/#for-homebrew-users-mac-os","text":"Liquigraph is part of the standard recipes of Homebrew . You just have to run: brew install liquigraph","title":"For Homebrew users (Mac OS)"},{"location":"download/#regular-download-unix-windows","text":"Liquigraph 4.x liquigraph-cli.zip liquigraph-cli.tar.gz liquigraph-cli.tar.bz2 Liquigraph 3.x liquigraph-cli.zip liquigraph-cli.tar.gz liquigraph-cli.tar.bz2 These archives contain two scripts: liquigraph-cli.sh for Unix users liquigraph-cli.bat for Windows users","title":"Regular download (Unix &amp; Windows)"},{"location":"download/#jvm","text":"The following artefacts are available through Maven Central. Info If you want to try a development version (a.k.a. a SNAPSHOT version), you do not need to build from sources. You can configure your build with a custom repository: <repositories> <repository> <id> ossrh </id> <name> Sonatype Snapshots </name> <url> https://oss.sonatype.org/content/repositories/snapshots </url> <snapshots> <enabled> true </enabled> </snapshots> <releases> <enabled> false </enabled> </releases> </repository> </repositories>","title":"JVM"},{"location":"download/#maven-plugin","text":"Liquigraph 4.x <plugin> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-maven-plugin </artifactId> <version> 4.0.3 </version> <configuration> <changelog> changelog.xml </changelog> <!-- classpath location --> <jdbcUri> jdbc:neo4j:bolt://localhost </jdbcUri> </configuration> <executions> <execution> <id> run-migrations </id> <goals> <goal> dry-run </goal> <goal> run </goal> </goals> </execution> </executions> </plugin> Liquigraph 3.x <plugin> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-maven-plugin </artifactId> <version> 3.1.2 </version> <configuration> <changelog> changelog.xml </changelog> <!-- classpath location --> <jdbcUri> jdbc:neo4j:bolt://localhost </jdbcUri> </configuration> <executions> <execution> <id> run-migrations </id> <goals> <goal> dry-run </goal> <goal> run </goal> </goals> </execution> </executions> </plugin>","title":"Maven plugin"},{"location":"download/#spring-boot-starter","text":"Liquigraph 4.x <dependency> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-spring-boot-starter </artifactId> <version> 4.0.3 </version> </dependency> Liquigraph 3.x <dependency> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-spring-boot-starter </artifactId> <version> 3.1.2 </version> </dependency>","title":"Spring Boot starter"},{"location":"download/#liquigraph-core","text":"Caution Liquigraph is better used through the CLI , Maven plugin or Spring Boot starter. If you want to build an integration, please file an issue and let's discuss! Liquigraph 4.x <dependency> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-core </artifactId> <version> 4.0.3 </version> </dependency> Liquigraph 3.x <dependency> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-core </artifactId> <version> 3.1.2 </version> </dependency>","title":"Liquigraph Core"},{"location":"reference/","text":"Reference \u2693 Concepts \u2693 Change logs \u2693 A change log is a collection of change set s. Liquigraph needs to be configured with a single change log, sometimes known as main change log. 1 2 3 4 5 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation= \"https://www.liquigraph.org/schema/1.0/liquigraph.xsd\" > <!-- minimal change log --> </changelog> A change log file may include other relative change log files and/or define change sets. Liquigraph will pre-process such inclusions and resolve them to a single change log document. The following example change log assume this folder structure: . \u251c\u2500\u2500 1 .0 \u2502 \u2514\u2500\u2500 changelog.xml \u251c\u2500\u2500 2 .0 \u2502 \u2514\u2500\u2500 changelog.xml \u2514\u2500\u2500 changelog.xml 1 2 3 4 5 6 7 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation= \"https://www.liquigraph.org/schema/1.0/liquigraph.xsd\" > <import resource= \"1.0/changelog.xml\" /> <import resource= \"2.0/changelog.xml\" /> </changelog> In that example, the change sets of 1.0/changelog.xml will be executed in declaration order, before the ones of 2.0/changelog.xml . Info Contrary to Liquibase, Liquigraph does not support folder import. Change sets \u2693 Change set s are uniquely identified by the combination of ID and author. Note IDs must remain unique within a change log file , this is a requirement of the XML specification. ID duplicates are allowed across files. Change sets are globally ordered by their execution (transaction) timestamp. They define at least 1 Cypher query. Warning Liquigraph only supports XML . As a consequence, any query that includes an XML entity (such as < or > ) needs to be surrounded with <![CDATA[ and ]]> blocks. \u274c Invalid change set: 1 2 3 <changeset id= \"fix-minimum-value\" author= \"florent.biville\" > <query> MATCH (n:SomeNode) WHERE n.value < 100 SET n.value = 100</query > </changeset> \u2705 Valid change set: 1 2 3 <changeset id= \"fix-minimum-value\" author= \"florent.biville\" > <query> <![CDATA[MATCH (n:SomeNode) WHERE n.value < 100 SET n.value = 100]]> </query> </changeset> Transactionality \u2693 Each change set is bound to its own transaction (unless it defines postconditions ). If any of the queries of a given change set fails, the transaction fails, and Liquigraph execution aborts. A change set failure does not affect the result of the execution of the previous change sets. Immutability and incrementality \u2693 By default, change sets are: immutable: their queries are not allowed to change (Liquigraph will reject the change set) incremental: they are executed only once To achieve these, Liquigraph stores the history of executed change sets in the same database. Persisted History Graph Data Model (powered by Arrows.app ) In particular, the checksum attribute on __LiquigraphChangeset nodes enables Liquigraph to detect whether a change set has changed since its last execution and react accordingly. While the common migration strategy is to add up change sets, not modify existing ones, you can set the run-on-change XML attribute as follows to allow for change set modifications: 1 2 3 <changeset id= \"create-sentence\" author= \"florent.biville\" run-on-change= \"true\" > <query> CREATE (n:Sentence {text:'Hello monde!'}) </query> </changeset> Note This kind of change sets will only run again if and only if their queries change. If you need change sets to always run, you can set the run-always XML attribute as follows: 1 2 3 4 5 6 <changeset id= \"maintain-node-count\" author= \"florent.biville\" run-always= \"true\" > <query> MATCH (n) WHERE NONE(label IN LABELS(n) WHERE label STARTS WITH '__Liquigraph' OR label == 'Statistics') WITH COUNT(n) AS node_total MERGE (stats:Statistics) SET stats.node_total = node_total </query> </changeset> Caution Even if run-always is set to true , the change set is still not allowed to change. If the change set needs to be mutable, you need to set run-on-change as well. Conditional execution \u2693 By default, every change declared from the main change log file are potential candidates for execution. As explained before, what will run depends on the persisted history graph. That being said, there are additional ways to exclude change sets from being executed, regardless of the persisted history. Execution contexts \u2693 Liquigraph supports execution contexts. They are simple strings, specified as a Liquigraph configuration parameter. CLI ./liquigraph-cli.sh --execution-contexts = \"foo,bar\" # [...] other CLI options omitted for brevity Maven plugin <configuration> <!-- [...] other configuration settings omitted for brevity --> <executionContexts> foo,bar </executionContexts> </configuration> Spring Boot starter Simply add this to your application.properties : liquigraph.executionContexts = foo,bar On the other hand, change sets declare 0 to many execution contexts, as follows: 1 2 3 <changeset id= \"create-sentence\" author= \"florent.biville\" contexts= \"foo,bar\" > <query> CREATE (n:Sentence {text:'Hello monde!'}) </query> </changeset> They will be matched under either of the following circumstances: Liquigraph is configured to run without any execution context The change set does not declare any execution context At least one of the execution contexts declared by the change set matches one of the configured Liquigraph execution contexts Preconditions \u2693 Change sets can optionally define preconditions. As their name suggests, these are custom checks that are run before the actual change set queries are executed. These custom checks are expressed as Cypher queries. The queries must return a single row, with a single column named result . 1 2 3 4 5 6 <changeset id= \"create-sentence\" author= \"florent.biville\" > <precondition> <!-- missing if-not-met attribute, more on that below --> <query> RETURN true AS result </query> </precondition> <query> CREATE (n:Sentence {text:'Hello monde!'}) </query> </changeset> The checks can be expressed as several Cypher queries, combined with boolean \" XML operators\" ( <and> and <or> are supported). 1 2 3 4 5 6 7 8 9 10 11 12 <changeset id= \"create-sentence\" author= \"florent.biville\" > <precondition> <!-- missing if-not-met attribute, more on that below --> <or> <query> MATCH (n) RETURN COUNT(n) % 2 = 0 AS result </query> <and> <query> MATCH (n:Sentence) RETURN n.text CONTAINS 'e' AS result </query> <query> MATCH (n) RETURN COUNT(n) % 2 = 1 AS result </query> </and> </or> </precondition> <query> CREATE (n:Sentence {text:'Hello monde!'}) </query> </changeset> As indicated in the snippets, the if-not-met attribute must be defined as well. This attribute defines the error handling strategy to follow when the precondition fails. Three strategies are currently implemented: CONTINUE : ignore the precondition error, skip the corresponding change set queries execution MARK_AS_EXECUTED : ignore the precondition error, skip the corresponding change set but persist the change set in the history graph as if it was executed FAIL : fail the transaction, report the precondition error (Liquigraph execution stops at this point) <changeset id= \"create-sentence\" author= \"florent.biville\" > <precondition if-not-met= \"MARK_AS_EXECUTED\" > <or> <query> MATCH (n) RETURN COUNT(n) % 2 = 0 AS result </query> <and> <query> MATCH (n:Sentence) RETURN n.text CONTAINS 'e' AS result </query> <query> MATCH (n) RETURN COUNT(n) % 2 = 1 AS result </query> </and> </or> </precondition> <query> CREATE (n:Sentence {text:'Hello monde!'}) </query> </changeset> Postconditions \u2693 Postconditions allow to run the queries of a change set by batch, until there is no more batch to execute. This can be useful if the change set queries affect many data elements in the graph. Without postconditions, such queries can cause memory overconsumption, or worse, crash the Neo4j server. Warning Change sets with postconditions do not run in a single transaction. There are instead as many transactions as batches to execute. As a consequence, if a batch execution fails, the previous batch transactions are not affected. They are committed to the graph. In the following example, the change set single query deletes relationships 1000 by 1000, until the postcondition query returns false . Like preconditions, the custom check is expressed as Cypher queries. The queries must return a single row, with a single column named result . The check can be expressed as several Cypher queries, combined with boolean \" XML operators\" ( <and> and <or> are supported). 1 2 3 4 5 6 <changeset id= \"delete-relationships-by-batch\" author= \"florent.biville\" > <query> MATCH ()-[r]->() WITH r LIMIT 1000 DELETE r </query> <postcondition> <query> MATCH ()-[r]->() WITH COUNT(r) AS count RETURN count = 0 AS result </query> </postcondition> </changeset> Configuration \u2693 General considerations \u2693 Connection URI \u2693 Starting with version 3, Liquigraph relies on the official JDBC driver for Neo4j . As a consequence, Liquigraph expects the connection URI to be specified in the JDBC format . The following sections cover the URI variants, depending on: the version of the Neo4j server the transport ( HTTP , Bolt , embedded) if applicable, the server typology (in-cluster vs. standalone) You can append parameters to the connection URI (such as database ), as documented here . Finally, the driver class name needs to be specified only when using the Spring Boot module. Warning Starting with Liquigraph version 3, the embedded transport is not supported anymore. Managed services such as Neo4j Aura only support the Bolt transport. Neo4j 4.x Transport Typology Expected URI form Driver class name Bolt standalone jdbc:neo4j:bolt:HOST:port org.neo4j.jdbc.bolt.BoltDriver Bolt in-cluster jdbc:neo4j:neo4j:HOST:port org.neo4j.jdbc.boltrouting.BoltRoutingNeo4jDriver HTTP N/A jdbc:neo4j:http(s):HOST:port org.neo4j.jdbc.http.HttpDriver Caution neo4j+s , neo4j+ssc , bolt+s and bolt+ssc Neo4j 4.x schemes are only supported by the JDBC driver version 4.0.3 or later. Earlier 4.0.x versions will not work properly. Tip If you want to connect to a Neo4j Aura instance, make sure to use the form jdbc:neo4j:neo4j+s://HOST (and specify org.neo4j.jdbc.boltrouting.BoltRoutingNeo4jDriver if you are a Spring Boot user) Neo4j 3.x Transport Typology Expected URI form Driver class name Bolt standalone jdbc:neo4j:bolt:HOST:port org.neo4j.jdbc.bolt.BoltDriver Bolt in-cluster jdbc:neo4j:bolt+routing:HOST:port org.neo4j.jdbc.boltrouting.BoltRoutingNeo4jDriver HTTP N/A jdbc:neo4j:http(s):HOST:port org.neo4j.jdbc.http.HttpDriver Multi-tenancy support \u2693 Starting with 4.x , Neo4j is multi-tenant. Each Neo4j server may host 2 ( system and the default neo4j ) to many databases. The target database is configured through the connection URI database parameter . For instance, here is a connection URI that connect to Neo4j with the Bolt transport on the default port, and against the some-database database: jdbc:neo4j:bolt:example.com?database=some-database . Note Liquigraph always persists the history graph in the same database as the one the migrations target. There is currently no way to store the history graph in another database. Clients \u2693 CLI \u2693 Usage: liquigraph [ options ] [ command ] [ command options ] Options: --help, -h Get this help --version, -v Show the version Commands: dry-run Simulate the execution of Liquigraph migrations Usage: dry-run [ options ] Options: * --changelog, -c Master Liquigraph changelog location. Prefix with 'classpath:' if location is in classpath --database, -db Graph DB database * --dry-run-output-directory, -d, --output-directory Output directory path into which changeset queries will be written. --execution-contexts, -x Comma-separated list of Liquigraph execution contexts Default: <empty string> * --graph-db-uri, -g Graph JDBC URI: - jdbc:neo4j:http://host:port/ - jdbc:neo4j:https://host:port/ - jdbc:neo4j:bolt://host:port/ --password, -p Graph DB password --username, -u Graph DB username run Execute Liquigraph migrations Usage: run [ options ] Options: * --changelog, -c Master Liquigraph changelog location. Prefix with 'classpath:' if location is in classpath --database, -db Graph DB database --execution-contexts, -x Comma-separated list of Liquigraph execution contexts Default: <empty string> * --graph-db-uri, -g Graph JDBC URI: - jdbc:neo4j:http://host:port/ - jdbc:neo4j:https://host:port/ - jdbc:neo4j:bolt://host:port/ --password, -p Graph DB password --username, -u Graph DB username Maven plugin \u2693 Please check the reference site: Neo4j 4.x Plugin site v4 . Neo4j 3.x Plugin site v3 . Spring Boot starter \u2693 Available configuration options: Property name Type Description Default value (if any) liquigraph.change-log String Path to change log file classpath:/db/liquigraph/changelog.xml liquigraph.enabled boolean Whether Liquigraph is enabled true liquigraph.execution-contexts String[] Liquigraph execution contexts [] liquigraph.password String Neo4j password N/A liquigraph.url String JDBC URL of the Neo4j server N/A liquigraph.user String Neo4j username N/A","title":"Reference"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"reference/#concepts","text":"","title":"Concepts"},{"location":"reference/#change-logs","text":"A change log is a collection of change set s. Liquigraph needs to be configured with a single change log, sometimes known as main change log. 1 2 3 4 5 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation= \"https://www.liquigraph.org/schema/1.0/liquigraph.xsd\" > <!-- minimal change log --> </changelog> A change log file may include other relative change log files and/or define change sets. Liquigraph will pre-process such inclusions and resolve them to a single change log document. The following example change log assume this folder structure: . \u251c\u2500\u2500 1 .0 \u2502 \u2514\u2500\u2500 changelog.xml \u251c\u2500\u2500 2 .0 \u2502 \u2514\u2500\u2500 changelog.xml \u2514\u2500\u2500 changelog.xml 1 2 3 4 5 6 7 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation= \"https://www.liquigraph.org/schema/1.0/liquigraph.xsd\" > <import resource= \"1.0/changelog.xml\" /> <import resource= \"2.0/changelog.xml\" /> </changelog> In that example, the change sets of 1.0/changelog.xml will be executed in declaration order, before the ones of 2.0/changelog.xml . Info Contrary to Liquibase, Liquigraph does not support folder import.","title":"Change logs"},{"location":"reference/#change-sets","text":"Change set s are uniquely identified by the combination of ID and author. Note IDs must remain unique within a change log file , this is a requirement of the XML specification. ID duplicates are allowed across files. Change sets are globally ordered by their execution (transaction) timestamp. They define at least 1 Cypher query. Warning Liquigraph only supports XML . As a consequence, any query that includes an XML entity (such as < or > ) needs to be surrounded with <![CDATA[ and ]]> blocks. \u274c Invalid change set: 1 2 3 <changeset id= \"fix-minimum-value\" author= \"florent.biville\" > <query> MATCH (n:SomeNode) WHERE n.value < 100 SET n.value = 100</query > </changeset> \u2705 Valid change set: 1 2 3 <changeset id= \"fix-minimum-value\" author= \"florent.biville\" > <query> <![CDATA[MATCH (n:SomeNode) WHERE n.value < 100 SET n.value = 100]]> </query> </changeset>","title":"Change sets"},{"location":"reference/#transactionality","text":"Each change set is bound to its own transaction (unless it defines postconditions ). If any of the queries of a given change set fails, the transaction fails, and Liquigraph execution aborts. A change set failure does not affect the result of the execution of the previous change sets.","title":"Transactionality"},{"location":"reference/#immutability-and-incrementality","text":"By default, change sets are: immutable: their queries are not allowed to change (Liquigraph will reject the change set) incremental: they are executed only once To achieve these, Liquigraph stores the history of executed change sets in the same database. Persisted History Graph Data Model (powered by Arrows.app ) In particular, the checksum attribute on __LiquigraphChangeset nodes enables Liquigraph to detect whether a change set has changed since its last execution and react accordingly. While the common migration strategy is to add up change sets, not modify existing ones, you can set the run-on-change XML attribute as follows to allow for change set modifications: 1 2 3 <changeset id= \"create-sentence\" author= \"florent.biville\" run-on-change= \"true\" > <query> CREATE (n:Sentence {text:'Hello monde!'}) </query> </changeset> Note This kind of change sets will only run again if and only if their queries change. If you need change sets to always run, you can set the run-always XML attribute as follows: 1 2 3 4 5 6 <changeset id= \"maintain-node-count\" author= \"florent.biville\" run-always= \"true\" > <query> MATCH (n) WHERE NONE(label IN LABELS(n) WHERE label STARTS WITH '__Liquigraph' OR label == 'Statistics') WITH COUNT(n) AS node_total MERGE (stats:Statistics) SET stats.node_total = node_total </query> </changeset> Caution Even if run-always is set to true , the change set is still not allowed to change. If the change set needs to be mutable, you need to set run-on-change as well.","title":"Immutability and incrementality"},{"location":"reference/#conditional-execution","text":"By default, every change declared from the main change log file are potential candidates for execution. As explained before, what will run depends on the persisted history graph. That being said, there are additional ways to exclude change sets from being executed, regardless of the persisted history.","title":"Conditional execution"},{"location":"reference/#execution-contexts","text":"Liquigraph supports execution contexts. They are simple strings, specified as a Liquigraph configuration parameter. CLI ./liquigraph-cli.sh --execution-contexts = \"foo,bar\" # [...] other CLI options omitted for brevity Maven plugin <configuration> <!-- [...] other configuration settings omitted for brevity --> <executionContexts> foo,bar </executionContexts> </configuration> Spring Boot starter Simply add this to your application.properties : liquigraph.executionContexts = foo,bar On the other hand, change sets declare 0 to many execution contexts, as follows: 1 2 3 <changeset id= \"create-sentence\" author= \"florent.biville\" contexts= \"foo,bar\" > <query> CREATE (n:Sentence {text:'Hello monde!'}) </query> </changeset> They will be matched under either of the following circumstances: Liquigraph is configured to run without any execution context The change set does not declare any execution context At least one of the execution contexts declared by the change set matches one of the configured Liquigraph execution contexts","title":"Execution contexts"},{"location":"reference/#preconditions","text":"Change sets can optionally define preconditions. As their name suggests, these are custom checks that are run before the actual change set queries are executed. These custom checks are expressed as Cypher queries. The queries must return a single row, with a single column named result . 1 2 3 4 5 6 <changeset id= \"create-sentence\" author= \"florent.biville\" > <precondition> <!-- missing if-not-met attribute, more on that below --> <query> RETURN true AS result </query> </precondition> <query> CREATE (n:Sentence {text:'Hello monde!'}) </query> </changeset> The checks can be expressed as several Cypher queries, combined with boolean \" XML operators\" ( <and> and <or> are supported). 1 2 3 4 5 6 7 8 9 10 11 12 <changeset id= \"create-sentence\" author= \"florent.biville\" > <precondition> <!-- missing if-not-met attribute, more on that below --> <or> <query> MATCH (n) RETURN COUNT(n) % 2 = 0 AS result </query> <and> <query> MATCH (n:Sentence) RETURN n.text CONTAINS 'e' AS result </query> <query> MATCH (n) RETURN COUNT(n) % 2 = 1 AS result </query> </and> </or> </precondition> <query> CREATE (n:Sentence {text:'Hello monde!'}) </query> </changeset> As indicated in the snippets, the if-not-met attribute must be defined as well. This attribute defines the error handling strategy to follow when the precondition fails. Three strategies are currently implemented: CONTINUE : ignore the precondition error, skip the corresponding change set queries execution MARK_AS_EXECUTED : ignore the precondition error, skip the corresponding change set but persist the change set in the history graph as if it was executed FAIL : fail the transaction, report the precondition error (Liquigraph execution stops at this point) <changeset id= \"create-sentence\" author= \"florent.biville\" > <precondition if-not-met= \"MARK_AS_EXECUTED\" > <or> <query> MATCH (n) RETURN COUNT(n) % 2 = 0 AS result </query> <and> <query> MATCH (n:Sentence) RETURN n.text CONTAINS 'e' AS result </query> <query> MATCH (n) RETURN COUNT(n) % 2 = 1 AS result </query> </and> </or> </precondition> <query> CREATE (n:Sentence {text:'Hello monde!'}) </query> </changeset>","title":"Preconditions"},{"location":"reference/#postconditions","text":"Postconditions allow to run the queries of a change set by batch, until there is no more batch to execute. This can be useful if the change set queries affect many data elements in the graph. Without postconditions, such queries can cause memory overconsumption, or worse, crash the Neo4j server. Warning Change sets with postconditions do not run in a single transaction. There are instead as many transactions as batches to execute. As a consequence, if a batch execution fails, the previous batch transactions are not affected. They are committed to the graph. In the following example, the change set single query deletes relationships 1000 by 1000, until the postcondition query returns false . Like preconditions, the custom check is expressed as Cypher queries. The queries must return a single row, with a single column named result . The check can be expressed as several Cypher queries, combined with boolean \" XML operators\" ( <and> and <or> are supported). 1 2 3 4 5 6 <changeset id= \"delete-relationships-by-batch\" author= \"florent.biville\" > <query> MATCH ()-[r]->() WITH r LIMIT 1000 DELETE r </query> <postcondition> <query> MATCH ()-[r]->() WITH COUNT(r) AS count RETURN count = 0 AS result </query> </postcondition> </changeset>","title":"Postconditions"},{"location":"reference/#configuration","text":"","title":"Configuration"},{"location":"reference/#general-considerations","text":"","title":"General considerations"},{"location":"reference/#connection-uri","text":"Starting with version 3, Liquigraph relies on the official JDBC driver for Neo4j . As a consequence, Liquigraph expects the connection URI to be specified in the JDBC format . The following sections cover the URI variants, depending on: the version of the Neo4j server the transport ( HTTP , Bolt , embedded) if applicable, the server typology (in-cluster vs. standalone) You can append parameters to the connection URI (such as database ), as documented here . Finally, the driver class name needs to be specified only when using the Spring Boot module. Warning Starting with Liquigraph version 3, the embedded transport is not supported anymore. Managed services such as Neo4j Aura only support the Bolt transport. Neo4j 4.x Transport Typology Expected URI form Driver class name Bolt standalone jdbc:neo4j:bolt:HOST:port org.neo4j.jdbc.bolt.BoltDriver Bolt in-cluster jdbc:neo4j:neo4j:HOST:port org.neo4j.jdbc.boltrouting.BoltRoutingNeo4jDriver HTTP N/A jdbc:neo4j:http(s):HOST:port org.neo4j.jdbc.http.HttpDriver Caution neo4j+s , neo4j+ssc , bolt+s and bolt+ssc Neo4j 4.x schemes are only supported by the JDBC driver version 4.0.3 or later. Earlier 4.0.x versions will not work properly. Tip If you want to connect to a Neo4j Aura instance, make sure to use the form jdbc:neo4j:neo4j+s://HOST (and specify org.neo4j.jdbc.boltrouting.BoltRoutingNeo4jDriver if you are a Spring Boot user) Neo4j 3.x Transport Typology Expected URI form Driver class name Bolt standalone jdbc:neo4j:bolt:HOST:port org.neo4j.jdbc.bolt.BoltDriver Bolt in-cluster jdbc:neo4j:bolt+routing:HOST:port org.neo4j.jdbc.boltrouting.BoltRoutingNeo4jDriver HTTP N/A jdbc:neo4j:http(s):HOST:port org.neo4j.jdbc.http.HttpDriver","title":"Connection URI"},{"location":"reference/#multi-tenancy-support","text":"Starting with 4.x , Neo4j is multi-tenant. Each Neo4j server may host 2 ( system and the default neo4j ) to many databases. The target database is configured through the connection URI database parameter . For instance, here is a connection URI that connect to Neo4j with the Bolt transport on the default port, and against the some-database database: jdbc:neo4j:bolt:example.com?database=some-database . Note Liquigraph always persists the history graph in the same database as the one the migrations target. There is currently no way to store the history graph in another database.","title":"Multi-tenancy support"},{"location":"reference/#clients","text":"","title":"Clients"},{"location":"reference/#cli","text":"Usage: liquigraph [ options ] [ command ] [ command options ] Options: --help, -h Get this help --version, -v Show the version Commands: dry-run Simulate the execution of Liquigraph migrations Usage: dry-run [ options ] Options: * --changelog, -c Master Liquigraph changelog location. Prefix with 'classpath:' if location is in classpath --database, -db Graph DB database * --dry-run-output-directory, -d, --output-directory Output directory path into which changeset queries will be written. --execution-contexts, -x Comma-separated list of Liquigraph execution contexts Default: <empty string> * --graph-db-uri, -g Graph JDBC URI: - jdbc:neo4j:http://host:port/ - jdbc:neo4j:https://host:port/ - jdbc:neo4j:bolt://host:port/ --password, -p Graph DB password --username, -u Graph DB username run Execute Liquigraph migrations Usage: run [ options ] Options: * --changelog, -c Master Liquigraph changelog location. Prefix with 'classpath:' if location is in classpath --database, -db Graph DB database --execution-contexts, -x Comma-separated list of Liquigraph execution contexts Default: <empty string> * --graph-db-uri, -g Graph JDBC URI: - jdbc:neo4j:http://host:port/ - jdbc:neo4j:https://host:port/ - jdbc:neo4j:bolt://host:port/ --password, -p Graph DB password --username, -u Graph DB username","title":"CLI"},{"location":"reference/#maven-plugin","text":"Please check the reference site: Neo4j 4.x Plugin site v4 . Neo4j 3.x Plugin site v3 .","title":"Maven plugin"},{"location":"reference/#spring-boot-starter","text":"Available configuration options: Property name Type Description Default value (if any) liquigraph.change-log String Path to change log file classpath:/db/liquigraph/changelog.xml liquigraph.enabled boolean Whether Liquigraph is enabled true liquigraph.execution-contexts String[] Liquigraph execution contexts [] liquigraph.password String Neo4j password N/A liquigraph.url String JDBC URL of the Neo4j server N/A liquigraph.user String Neo4j username N/A","title":"Spring Boot starter"},{"location":"includes/_abbreviations/","text":"","title":" abbreviations"},{"location":"includes/_dry-run-beginning/","text":"It is a good practice to first execute a dry run. A dry run does not alter your database. The database needs to be online, so that Liquigraph can properly detect which change sets are to be selected (based on whether they already ran, whether they match the execution context ...). It helps you make sure that: your connection settings are correct the selected change sets are the ones you expect","title":" dry run beginning"},{"location":"includes/_quickstart_beginning/","text":"Basic concepts \u2693 Liquigraph requires a single entry point, also known as a change log file. This file can include other change log files and/or define change set s. Every change set is executed in a separate transaction. They define at least 1 Cypher query. These Cypher queries define the data (or indices/constraints ) that will be created, modified or deleted from the target database. Caution Neo4j disallows mixing index/constraint with regular \"data\" operations within the same transaction. Such a transaction will always fail. As a consequence, index/constraint operations must be defined in separate Liquigraph change sets. Change sets are uniquely identified by their ID and author name. By default, they also are: incremental: they are allowed to run only once. immutable: their queries are not allowed to change. Learn how to change these defaults, and more, in the reference documentation . First migrations \u2693 Change log creation \u2693 Save the following change log file: 1 2 3 4 5 6 7 8 9 10 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation= \"https://www.liquigraph.org/schema/1.0/liquigraph.xsd\" > <changeset id= \"sentence-initialization\" author= \"florent-biville\" > <query> CREATE (n:Sentence {text:\"Hello monde!\"}) RETURN n </query> </changeset> <changeset id= \"sentence-correction\" author= \"florent-biville\" > <query> MATCH (n:Sentence {text:\"Hello monde!\"}) SET n.text=\"Hello world!\" RETURN n </query> </changeset> </changelog> The change log defines two change sets, which are executed in order, in separate transactions: The first change set defines a single query, which creates a node, with a Sentence label and a simple textual property called text . The second change set defines a single Cypher query as well, which finds the node pattern and updates the text property accordingly. If the Cypher syntax looks unfamiliar, feel free to follow this official tutorial . Info The location of this file will be called CHANGELOG_FILE throughout the rest of the tutorial. Note Contrary to Liquibase, Liquigraph only supports XML for defining change logs. Connection URI \u2693 To keep things simple, we will assume a standalone Neo4j server is running on your machine, via Neo4j Desktop or Docker for instance. The connection URI will be jdbc:neo4j:bolt://localhost , username neo4j and the password changeme . Depending on Neo4j versions, Neo4j server typology and Liquigraph client, connection URI can vary greatly. The configuration is covered in much greater details in the reference documentation .","title":" quickstart beginning"},{"location":"includes/_quickstart_beginning/#basic-concepts","text":"Liquigraph requires a single entry point, also known as a change log file. This file can include other change log files and/or define change set s. Every change set is executed in a separate transaction. They define at least 1 Cypher query. These Cypher queries define the data (or indices/constraints ) that will be created, modified or deleted from the target database. Caution Neo4j disallows mixing index/constraint with regular \"data\" operations within the same transaction. Such a transaction will always fail. As a consequence, index/constraint operations must be defined in separate Liquigraph change sets. Change sets are uniquely identified by their ID and author name. By default, they also are: incremental: they are allowed to run only once. immutable: their queries are not allowed to change. Learn how to change these defaults, and more, in the reference documentation .","title":"Basic concepts"},{"location":"includes/_quickstart_beginning/#first-migrations","text":"","title":"First migrations"},{"location":"includes/_quickstart_beginning/#change-log-creation","text":"Save the following change log file: 1 2 3 4 5 6 7 8 9 10 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation= \"https://www.liquigraph.org/schema/1.0/liquigraph.xsd\" > <changeset id= \"sentence-initialization\" author= \"florent-biville\" > <query> CREATE (n:Sentence {text:\"Hello monde!\"}) RETURN n </query> </changeset> <changeset id= \"sentence-correction\" author= \"florent-biville\" > <query> MATCH (n:Sentence {text:\"Hello monde!\"}) SET n.text=\"Hello world!\" RETURN n </query> </changeset> </changelog> The change log defines two change sets, which are executed in order, in separate transactions: The first change set defines a single query, which creates a node, with a Sentence label and a simple textual property called text . The second change set defines a single Cypher query as well, which finds the node pattern and updates the text property accordingly. If the Cypher syntax looks unfamiliar, feel free to follow this official tutorial . Info The location of this file will be called CHANGELOG_FILE throughout the rest of the tutorial. Note Contrary to Liquibase, Liquigraph only supports XML for defining change logs.","title":"Change log creation"},{"location":"includes/_quickstart_beginning/#connection-uri","text":"To keep things simple, we will assume a standalone Neo4j server is running on your machine, via Neo4j Desktop or Docker for instance. The connection URI will be jdbc:neo4j:bolt://localhost , username neo4j and the password changeme . Depending on Neo4j versions, Neo4j server typology and Liquigraph client, connection URI can vary greatly. The configuration is covered in much greater details in the reference documentation .","title":"Connection URI"},{"location":"includes/_quickstart_end/","text":"You can then check the data has been added in Neo4j Browser with the following Cypher query: MATCH ( sentence : Sentence ) RETURN sentence . text AS text The result should be \"Hello world!\". You can re-run the same Liquigraph command several times and observe that the graph remains unchanged. In other words, the following Cypher query: MATCH ( sentence : Sentence ) RETURN COUNT ( sentence ) ... should indeed always return 1. Good to know If you ever run a less specific Cypher query such as MATCH (n) RETURN n , you will see that more node and relationships are returned. This is normal: Liquigraph persists the change log history in the same database. The change log history graph structure is covered in much more details in the reference documentation .","title":" quickstart end"},{"location":"quickstart/cli/","text":"CLI \u2693 Liquigraph provides a CLI . It is a good fit for users working on non- JVM applications or with a standalone Neo4j deployment directly. Prerequisites \u2693 Make sure a JRE is set up on the machine running the CLI . For Neo4j 3.x, the minimal JRE version is 8. For Neo4j 4.x, the minimal JRE version is 11. CLI download \u2693 Please refer to the download section to download the CLI first. The rest of the tutorial assumes a Unix OS and will therefore show examples with liquigraph-cli.sh . Info Homebrew (Mac OS ) users need to replace liquigraph-cli.sh with liquigraph . Windows users need to replace liquigraph-cli.sh with liquigraph-cli.bat . Let's now make sure the CLI runs without any issue: ./liquigraph-cli.sh --help Usage: liquigraph [ options ] Options: * --changelog, -c Master Liquigraph changelog location. Prefix with 'classpath:' if location is in classpath // [ ... ] omitted for brevity --help, -h Get this help --password, -p Graph DB password ( remote only ) --username, -u Graph DB username ( remote only ) --version, -v Show the version Basic concepts \u2693 Liquigraph requires a single entry point, also known as a change log file. This file can include other change log files and/or define change set s. Every change set is executed in a separate transaction. They define at least 1 Cypher query. These Cypher queries define the data (or indices/constraints ) that will be created, modified or deleted from the target database. Caution Neo4j disallows mixing index/constraint with regular \"data\" operations within the same transaction. Such a transaction will always fail. As a consequence, index/constraint operations must be defined in separate Liquigraph change sets. Change sets are uniquely identified by their ID and author name. By default, they also are: incremental: they are allowed to run only once. immutable: their queries are not allowed to change. Learn how to change these defaults, and more, in the reference documentation . First migrations \u2693 Change log creation \u2693 Save the following change log file: 1 2 3 4 5 6 7 8 9 10 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation= \"https://www.liquigraph.org/schema/1.0/liquigraph.xsd\" > <changeset id= \"sentence-initialization\" author= \"florent-biville\" > <query> CREATE (n:Sentence {text:\"Hello monde!\"}) RETURN n </query> </changeset> <changeset id= \"sentence-correction\" author= \"florent-biville\" > <query> MATCH (n:Sentence {text:\"Hello monde!\"}) SET n.text=\"Hello world!\" RETURN n </query> </changeset> </changelog> The change log defines two change sets, which are executed in order, in separate transactions: The first change set defines a single query, which creates a node, with a Sentence label and a simple textual property called text . The second change set defines a single Cypher query as well, which finds the node pattern and updates the text property accordingly. If the Cypher syntax looks unfamiliar, feel free to follow this official tutorial . Info The location of this file will be called CHANGELOG_FILE throughout the rest of the tutorial. Note Contrary to Liquibase, Liquigraph only supports XML for defining change logs. Connection URI \u2693 To keep things simple, we will assume a standalone Neo4j server is running on your machine, via Neo4j Desktop or Docker for instance. The connection URI will be jdbc:neo4j:bolt://localhost , username neo4j and the password changeme . Depending on Neo4j versions, Neo4j server typology and Liquigraph client, connection URI can vary greatly. The configuration is covered in much greater details in the reference documentation . Dry run \u2693 It is a good practice to first execute a dry run. A dry run does not alter your database. The database needs to be online, so that Liquigraph can properly detect which change sets are to be selected (based on whether they already ran, whether they match the execution context ...). It helps you make sure that: your connection settings are correct the selected change sets are the ones you expect Besides the connection and change log settings, a temporary directory needs to be specified via the option --dry-run-output-directory (short version: -d ). In dry-run mode, Liquigraph generates a Cypher file into this directory. The Cypher file contains the queries of the change set that would be executed against the configured Neo4j database. ./liquigraph.sh --username neo4j \\ --password changeme \\ --graph-db-uri jdbc:neo4j:bolt://localhost \\ --changelog CHANGELOG_FILE \\ --dry-run-output-directory /path/to/directory Tip You can leave the password value out, and a secure prompt will appear. You can also read the password from a file with ./liquigraph.sh [...] --password < password.txt . This should result in a successful execution with a file named output.cypher in /path/to/directory : less /path/to/directory/output.cypher //Liquigraph changeset [ author: florent-biville, id: sentence-initialization ] //Liquigraph changeset [ executionContexts: none declared ] CREATE ( n:Sentence { text: \"Hello monde!\" }) RETURN n //Liquigraph changeset [ author: florent-biville, id: sentence-correction ] //Liquigraph changeset [ executionContexts: none declared ] MATCH ( n:Sentence { text: \"Hello monde!\" }) SET n.text = \"Hello world!\" RETURN n Note Contrary to Liquibase, Liquigraph only includes the queries of the matching change sets. Cypher queries executed for Liquigraph internal purposes are not included. Printing to the standard output is also currently unsupported. Run \u2693 Once the dry run is successful, you can finally execute the migrations. The CLI invocation remains almost the same, only the dry run directory parameter needs to go away: ./liquigraph.sh --username neo4j \\ --password changeme \\ --graph-db-uri jdbc:neo4j:bolt://localhost \\ --changelog CHANGELOG_FILE You can then check the data has been added in Neo4j Browser with the following Cypher query: MATCH ( sentence : Sentence ) RETURN sentence . text AS text The result should be \"Hello world!\". You can re-run the same Liquigraph command several times and observe that the graph remains unchanged. In other words, the following Cypher query: MATCH ( sentence : Sentence ) RETURN COUNT ( sentence ) ... should indeed always return 1. Good to know If you ever run a less specific Cypher query such as MATCH (n) RETURN n , you will see that more node and relationships are returned. This is normal: Liquigraph persists the change log history in the same database. The change log history graph structure is covered in much more details in the reference documentation .","title":"CLI"},{"location":"quickstart/cli/#cli","text":"Liquigraph provides a CLI . It is a good fit for users working on non- JVM applications or with a standalone Neo4j deployment directly.","title":"CLI"},{"location":"quickstart/cli/#prerequisites","text":"Make sure a JRE is set up on the machine running the CLI . For Neo4j 3.x, the minimal JRE version is 8. For Neo4j 4.x, the minimal JRE version is 11.","title":"Prerequisites"},{"location":"quickstart/cli/#cli-download","text":"Please refer to the download section to download the CLI first. The rest of the tutorial assumes a Unix OS and will therefore show examples with liquigraph-cli.sh . Info Homebrew (Mac OS ) users need to replace liquigraph-cli.sh with liquigraph . Windows users need to replace liquigraph-cli.sh with liquigraph-cli.bat . Let's now make sure the CLI runs without any issue: ./liquigraph-cli.sh --help Usage: liquigraph [ options ] Options: * --changelog, -c Master Liquigraph changelog location. Prefix with 'classpath:' if location is in classpath // [ ... ] omitted for brevity --help, -h Get this help --password, -p Graph DB password ( remote only ) --username, -u Graph DB username ( remote only ) --version, -v Show the version","title":"CLI download"},{"location":"quickstart/cli/#basic-concepts","text":"Liquigraph requires a single entry point, also known as a change log file. This file can include other change log files and/or define change set s. Every change set is executed in a separate transaction. They define at least 1 Cypher query. These Cypher queries define the data (or indices/constraints ) that will be created, modified or deleted from the target database. Caution Neo4j disallows mixing index/constraint with regular \"data\" operations within the same transaction. Such a transaction will always fail. As a consequence, index/constraint operations must be defined in separate Liquigraph change sets. Change sets are uniquely identified by their ID and author name. By default, they also are: incremental: they are allowed to run only once. immutable: their queries are not allowed to change. Learn how to change these defaults, and more, in the reference documentation .","title":"Basic concepts"},{"location":"quickstart/cli/#first-migrations","text":"","title":"First migrations"},{"location":"quickstart/cli/#change-log-creation","text":"Save the following change log file: 1 2 3 4 5 6 7 8 9 10 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation= \"https://www.liquigraph.org/schema/1.0/liquigraph.xsd\" > <changeset id= \"sentence-initialization\" author= \"florent-biville\" > <query> CREATE (n:Sentence {text:\"Hello monde!\"}) RETURN n </query> </changeset> <changeset id= \"sentence-correction\" author= \"florent-biville\" > <query> MATCH (n:Sentence {text:\"Hello monde!\"}) SET n.text=\"Hello world!\" RETURN n </query> </changeset> </changelog> The change log defines two change sets, which are executed in order, in separate transactions: The first change set defines a single query, which creates a node, with a Sentence label and a simple textual property called text . The second change set defines a single Cypher query as well, which finds the node pattern and updates the text property accordingly. If the Cypher syntax looks unfamiliar, feel free to follow this official tutorial . Info The location of this file will be called CHANGELOG_FILE throughout the rest of the tutorial. Note Contrary to Liquibase, Liquigraph only supports XML for defining change logs.","title":"Change log creation"},{"location":"quickstart/cli/#connection-uri","text":"To keep things simple, we will assume a standalone Neo4j server is running on your machine, via Neo4j Desktop or Docker for instance. The connection URI will be jdbc:neo4j:bolt://localhost , username neo4j and the password changeme . Depending on Neo4j versions, Neo4j server typology and Liquigraph client, connection URI can vary greatly. The configuration is covered in much greater details in the reference documentation .","title":"Connection URI"},{"location":"quickstart/cli/#dry-run","text":"It is a good practice to first execute a dry run. A dry run does not alter your database. The database needs to be online, so that Liquigraph can properly detect which change sets are to be selected (based on whether they already ran, whether they match the execution context ...). It helps you make sure that: your connection settings are correct the selected change sets are the ones you expect Besides the connection and change log settings, a temporary directory needs to be specified via the option --dry-run-output-directory (short version: -d ). In dry-run mode, Liquigraph generates a Cypher file into this directory. The Cypher file contains the queries of the change set that would be executed against the configured Neo4j database. ./liquigraph.sh --username neo4j \\ --password changeme \\ --graph-db-uri jdbc:neo4j:bolt://localhost \\ --changelog CHANGELOG_FILE \\ --dry-run-output-directory /path/to/directory Tip You can leave the password value out, and a secure prompt will appear. You can also read the password from a file with ./liquigraph.sh [...] --password < password.txt . This should result in a successful execution with a file named output.cypher in /path/to/directory : less /path/to/directory/output.cypher //Liquigraph changeset [ author: florent-biville, id: sentence-initialization ] //Liquigraph changeset [ executionContexts: none declared ] CREATE ( n:Sentence { text: \"Hello monde!\" }) RETURN n //Liquigraph changeset [ author: florent-biville, id: sentence-correction ] //Liquigraph changeset [ executionContexts: none declared ] MATCH ( n:Sentence { text: \"Hello monde!\" }) SET n.text = \"Hello world!\" RETURN n Note Contrary to Liquibase, Liquigraph only includes the queries of the matching change sets. Cypher queries executed for Liquigraph internal purposes are not included. Printing to the standard output is also currently unsupported.","title":"Dry run"},{"location":"quickstart/cli/#run","text":"Once the dry run is successful, you can finally execute the migrations. The CLI invocation remains almost the same, only the dry run directory parameter needs to go away: ./liquigraph.sh --username neo4j \\ --password changeme \\ --graph-db-uri jdbc:neo4j:bolt://localhost \\ --changelog CHANGELOG_FILE You can then check the data has been added in Neo4j Browser with the following Cypher query: MATCH ( sentence : Sentence ) RETURN sentence . text AS text The result should be \"Hello world!\". You can re-run the same Liquigraph command several times and observe that the graph remains unchanged. In other words, the following Cypher query: MATCH ( sentence : Sentence ) RETURN COUNT ( sentence ) ... should indeed always return 1. Good to know If you ever run a less specific Cypher query such as MATCH (n) RETURN n , you will see that more node and relationships are returned. This is normal: Liquigraph persists the change log history in the same database. The change log history graph structure is covered in much more details in the reference documentation .","title":"Run"},{"location":"quickstart/maven/","text":"Maven plugin \u2693 Liquigraph provides a Maven plugin. This plugin is a good fit for: standalone executions of Liquigraph in environments where JVM tooling is already in place (like CI / CD pipelines e.g.). You might want to have a look at the Liquigraph CLI otherwise the automation of migrations before some other Maven plugin executes (such as Maven Failsafe Plugin for integration tests) Prerequisites \u2693 Make sure a JDK is set up on the machine running the Maven build. For Neo4j 3.x, the minimal JDK version is 8. For Neo4j 4.x, the minimal JDK version is 11. You will also need to install a recent version of Apache Maven . As a simple sanity check, javac --version , java --version and mvn --version should display the same JDK version. Basic concepts \u2693 Liquigraph requires a single entry point, also known as a change log file. This file can include other change log files and/or define change set s. Every change set is executed in a separate transaction. They define at least 1 Cypher query. These Cypher queries define the data (or indices/constraints ) that will be created, modified or deleted from the target database. Caution Neo4j disallows mixing index/constraint with regular \"data\" operations within the same transaction. Such a transaction will always fail. As a consequence, index/constraint operations must be defined in separate Liquigraph change sets. Change sets are uniquely identified by their ID and author name. By default, they also are: incremental: they are allowed to run only once. immutable: their queries are not allowed to change. Learn how to change these defaults, and more, in the reference documentation . First migrations \u2693 Change log creation \u2693 Save the following change log file: 1 2 3 4 5 6 7 8 9 10 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation= \"https://www.liquigraph.org/schema/1.0/liquigraph.xsd\" > <changeset id= \"sentence-initialization\" author= \"florent-biville\" > <query> CREATE (n:Sentence {text:\"Hello monde!\"}) RETURN n </query> </changeset> <changeset id= \"sentence-correction\" author= \"florent-biville\" > <query> MATCH (n:Sentence {text:\"Hello monde!\"}) SET n.text=\"Hello world!\" RETURN n </query> </changeset> </changelog> The change log defines two change sets, which are executed in order, in separate transactions: The first change set defines a single query, which creates a node, with a Sentence label and a simple textual property called text . The second change set defines a single Cypher query as well, which finds the node pattern and updates the text property accordingly. If the Cypher syntax looks unfamiliar, feel free to follow this official tutorial . Info The location of this file will be called CHANGELOG_FILE throughout the rest of the tutorial. Note Contrary to Liquibase, Liquigraph only supports XML for defining change logs. Connection URI \u2693 To keep things simple, we will assume a standalone Neo4j server is running on your machine, via Neo4j Desktop or Docker for instance. The connection URI will be jdbc:neo4j:bolt://localhost , username neo4j and the password changeme . Depending on Neo4j versions, Neo4j server typology and Liquigraph client, connection URI can vary greatly. The configuration is covered in much greater details in the reference documentation . A minimal POM file \u2693 For simplicity's sake, a standalone Maven build will be assumed. If that's not the case, simply copy the relevant sections of the following file: Liquigraph 4.x <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> com.example </groupId> <artifactId> liquigraph-maven-example </artifactId> <version> 0.0.1-SNAPSHOT </version> <packaging> jar </packaging> <name> liquigraph-maven-example </name> <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <project.reporting.outputEncoding> ${project.build.sourceEncoding} </project.reporting.outputEncoding> <maven.compiler.release> 11 </maven.compiler.release> </properties> <build> <plugins> <plugin> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-maven-plugin </artifactId> <version> 4.0.3 </version> <configuration> <changelog> changelog.xml </changelog> <jdbcUri> jdbc:neo4j:bolt://localhost </jdbcUri> <username> neo4j </username> <password> changeme </password> </configuration> </plugin> </plugins> </build> </project> Liquigraph 3.x <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> com.example </groupId> <artifactId> liquigraph-maven-example </artifactId> <version> 0.0.1-SNAPSHOT </version> <packaging> jar </packaging> <name> liquigraph-maven-example </name> <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <project.reporting.outputEncoding> ${project.build.sourceEncoding} </project.reporting.outputEncoding> <maven.compiler.source> 8 </maven.compiler.source> <maven.compiler.target> ${maven.compiler.source} </maven.compiler.target> </properties> <build> <plugins> <plugin> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-maven-plugin </artifactId> <version> 3.1.2 </version> <configuration> <changelog> changelog.xml </changelog> <jdbcUri> jdbc:neo4j:bolt://localhost </jdbcUri> <username> neo4j </username> <password> changeme </password> </configuration> </plugin> </plugins> </build> </project> Info Please refer to the download section to learn how to retrieve a Liquigraph SNAPSHOT version. Note CHANGELOG_FILE should be stored in src/main/resources/changelog.xml for the example to work. The following executions assumes that the current directory is the folder where pom.xml . Dry run \u2693 It is a good practice to first execute a dry run. A dry run does not alter your database. The database needs to be online, so that Liquigraph can properly detect which change sets are to be selected (based on whether they already ran, whether they match the execution context ...). It helps you make sure that: your connection settings are correct the selected change sets are the ones you expect Since the configuration is defined in the POM file, the execution is simply as follows: mvn compile liquigraph:dry-run This should result in a successful execution with a file named output.cypher in the generated target folder: less target/output.cypher //Liquigraph changeset [ author: florent-biville, id: sentence-initialization ] //Liquigraph changeset [ executionContexts: none declared ] CREATE ( n:Sentence { text: \"Hello monde!\" }) RETURN n //Liquigraph changeset [ author: florent-biville, id: sentence-correction ] //Liquigraph changeset [ executionContexts: none declared ] MATCH ( n:Sentence { text: \"Hello monde!\" }) SET n.text = \"Hello world!\" RETURN n Note Contrary to Liquibase, Liquigraph only includes the queries of the matching change sets. Cypher queries executed for Liquigraph internal purposes are not included. Printing to the standard output is also currently unsupported. Run \u2693 Once the dry run is successful, you can finally execute the migrations. The invocation is very similar, only the plugin target goal changes: mvn compile liquigraph:run You can then check the data has been added in Neo4j Browser with the following Cypher query: MATCH ( sentence : Sentence ) RETURN sentence . text AS text The result should be \"Hello world!\". You can re-run the same Liquigraph command several times and observe that the graph remains unchanged. In other words, the following Cypher query: MATCH ( sentence : Sentence ) RETURN COUNT ( sentence ) ... should indeed always return 1. Good to know If you ever run a less specific Cypher query such as MATCH (n) RETURN n , you will see that more node and relationships are returned. This is normal: Liquigraph persists the change log history in the same database. The change log history graph structure is covered in much more details in the reference documentation .","title":"Maven plugin"},{"location":"quickstart/maven/#maven-plugin","text":"Liquigraph provides a Maven plugin. This plugin is a good fit for: standalone executions of Liquigraph in environments where JVM tooling is already in place (like CI / CD pipelines e.g.). You might want to have a look at the Liquigraph CLI otherwise the automation of migrations before some other Maven plugin executes (such as Maven Failsafe Plugin for integration tests)","title":"Maven plugin"},{"location":"quickstart/maven/#prerequisites","text":"Make sure a JDK is set up on the machine running the Maven build. For Neo4j 3.x, the minimal JDK version is 8. For Neo4j 4.x, the minimal JDK version is 11. You will also need to install a recent version of Apache Maven . As a simple sanity check, javac --version , java --version and mvn --version should display the same JDK version.","title":"Prerequisites"},{"location":"quickstart/maven/#basic-concepts","text":"Liquigraph requires a single entry point, also known as a change log file. This file can include other change log files and/or define change set s. Every change set is executed in a separate transaction. They define at least 1 Cypher query. These Cypher queries define the data (or indices/constraints ) that will be created, modified or deleted from the target database. Caution Neo4j disallows mixing index/constraint with regular \"data\" operations within the same transaction. Such a transaction will always fail. As a consequence, index/constraint operations must be defined in separate Liquigraph change sets. Change sets are uniquely identified by their ID and author name. By default, they also are: incremental: they are allowed to run only once. immutable: their queries are not allowed to change. Learn how to change these defaults, and more, in the reference documentation .","title":"Basic concepts"},{"location":"quickstart/maven/#first-migrations","text":"","title":"First migrations"},{"location":"quickstart/maven/#change-log-creation","text":"Save the following change log file: 1 2 3 4 5 6 7 8 9 10 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation= \"https://www.liquigraph.org/schema/1.0/liquigraph.xsd\" > <changeset id= \"sentence-initialization\" author= \"florent-biville\" > <query> CREATE (n:Sentence {text:\"Hello monde!\"}) RETURN n </query> </changeset> <changeset id= \"sentence-correction\" author= \"florent-biville\" > <query> MATCH (n:Sentence {text:\"Hello monde!\"}) SET n.text=\"Hello world!\" RETURN n </query> </changeset> </changelog> The change log defines two change sets, which are executed in order, in separate transactions: The first change set defines a single query, which creates a node, with a Sentence label and a simple textual property called text . The second change set defines a single Cypher query as well, which finds the node pattern and updates the text property accordingly. If the Cypher syntax looks unfamiliar, feel free to follow this official tutorial . Info The location of this file will be called CHANGELOG_FILE throughout the rest of the tutorial. Note Contrary to Liquibase, Liquigraph only supports XML for defining change logs.","title":"Change log creation"},{"location":"quickstart/maven/#connection-uri","text":"To keep things simple, we will assume a standalone Neo4j server is running on your machine, via Neo4j Desktop or Docker for instance. The connection URI will be jdbc:neo4j:bolt://localhost , username neo4j and the password changeme . Depending on Neo4j versions, Neo4j server typology and Liquigraph client, connection URI can vary greatly. The configuration is covered in much greater details in the reference documentation .","title":"Connection URI"},{"location":"quickstart/maven/#a-minimal-pom-file","text":"For simplicity's sake, a standalone Maven build will be assumed. If that's not the case, simply copy the relevant sections of the following file: Liquigraph 4.x <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> com.example </groupId> <artifactId> liquigraph-maven-example </artifactId> <version> 0.0.1-SNAPSHOT </version> <packaging> jar </packaging> <name> liquigraph-maven-example </name> <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <project.reporting.outputEncoding> ${project.build.sourceEncoding} </project.reporting.outputEncoding> <maven.compiler.release> 11 </maven.compiler.release> </properties> <build> <plugins> <plugin> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-maven-plugin </artifactId> <version> 4.0.3 </version> <configuration> <changelog> changelog.xml </changelog> <jdbcUri> jdbc:neo4j:bolt://localhost </jdbcUri> <username> neo4j </username> <password> changeme </password> </configuration> </plugin> </plugins> </build> </project> Liquigraph 3.x <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> com.example </groupId> <artifactId> liquigraph-maven-example </artifactId> <version> 0.0.1-SNAPSHOT </version> <packaging> jar </packaging> <name> liquigraph-maven-example </name> <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <project.reporting.outputEncoding> ${project.build.sourceEncoding} </project.reporting.outputEncoding> <maven.compiler.source> 8 </maven.compiler.source> <maven.compiler.target> ${maven.compiler.source} </maven.compiler.target> </properties> <build> <plugins> <plugin> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-maven-plugin </artifactId> <version> 3.1.2 </version> <configuration> <changelog> changelog.xml </changelog> <jdbcUri> jdbc:neo4j:bolt://localhost </jdbcUri> <username> neo4j </username> <password> changeme </password> </configuration> </plugin> </plugins> </build> </project> Info Please refer to the download section to learn how to retrieve a Liquigraph SNAPSHOT version. Note CHANGELOG_FILE should be stored in src/main/resources/changelog.xml for the example to work. The following executions assumes that the current directory is the folder where pom.xml .","title":"A minimal POM file"},{"location":"quickstart/maven/#dry-run","text":"It is a good practice to first execute a dry run. A dry run does not alter your database. The database needs to be online, so that Liquigraph can properly detect which change sets are to be selected (based on whether they already ran, whether they match the execution context ...). It helps you make sure that: your connection settings are correct the selected change sets are the ones you expect Since the configuration is defined in the POM file, the execution is simply as follows: mvn compile liquigraph:dry-run This should result in a successful execution with a file named output.cypher in the generated target folder: less target/output.cypher //Liquigraph changeset [ author: florent-biville, id: sentence-initialization ] //Liquigraph changeset [ executionContexts: none declared ] CREATE ( n:Sentence { text: \"Hello monde!\" }) RETURN n //Liquigraph changeset [ author: florent-biville, id: sentence-correction ] //Liquigraph changeset [ executionContexts: none declared ] MATCH ( n:Sentence { text: \"Hello monde!\" }) SET n.text = \"Hello world!\" RETURN n Note Contrary to Liquibase, Liquigraph only includes the queries of the matching change sets. Cypher queries executed for Liquigraph internal purposes are not included. Printing to the standard output is also currently unsupported.","title":"Dry run"},{"location":"quickstart/maven/#run","text":"Once the dry run is successful, you can finally execute the migrations. The invocation is very similar, only the plugin target goal changes: mvn compile liquigraph:run You can then check the data has been added in Neo4j Browser with the following Cypher query: MATCH ( sentence : Sentence ) RETURN sentence . text AS text The result should be \"Hello world!\". You can re-run the same Liquigraph command several times and observe that the graph remains unchanged. In other words, the following Cypher query: MATCH ( sentence : Sentence ) RETURN COUNT ( sentence ) ... should indeed always return 1. Good to know If you ever run a less specific Cypher query such as MATCH (n) RETURN n , you will see that more node and relationships are returned. This is normal: Liquigraph persists the change log history in the same database. The change log history graph structure is covered in much more details in the reference documentation .","title":"Run"},{"location":"quickstart/spring-boot/","text":"Spring Boot \u2693 Liquigraph provides a Spring Boot starter. It is a good fit if your Spring Boot application owns (well-identified parts of) the data in Neo4j. Prerequisites \u2693 Make sure a JDK is set up on the machine running the CLI . For Neo4j 3.x, the minimal JDK version is 8. For Neo4j 4.x, the minimal JDK version is 11. Download \u2693 For this particular example, a simple Spring Boot application with a Maven build is assumed. Info You can bootstrap a project in a few clicks with Spring Initializr , the \"second best place on the Internet\" . You do not need to add any dependencies. Basic concepts \u2693 Liquigraph requires a single entry point, also known as a change log file. This file can include other change log files and/or define change set s. Every change set is executed in a separate transaction. They define at least 1 Cypher query. These Cypher queries define the data (or indices/constraints ) that will be created, modified or deleted from the target database. Caution Neo4j disallows mixing index/constraint with regular \"data\" operations within the same transaction. Such a transaction will always fail. As a consequence, index/constraint operations must be defined in separate Liquigraph change sets. Change sets are uniquely identified by their ID and author name. By default, they also are: incremental: they are allowed to run only once. immutable: their queries are not allowed to change. Learn how to change these defaults, and more, in the reference documentation . First migrations \u2693 Change log creation \u2693 Save the following change log file: 1 2 3 4 5 6 7 8 9 10 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation= \"https://www.liquigraph.org/schema/1.0/liquigraph.xsd\" > <changeset id= \"sentence-initialization\" author= \"florent-biville\" > <query> CREATE (n:Sentence {text:\"Hello monde!\"}) RETURN n </query> </changeset> <changeset id= \"sentence-correction\" author= \"florent-biville\" > <query> MATCH (n:Sentence {text:\"Hello monde!\"}) SET n.text=\"Hello world!\" RETURN n </query> </changeset> </changelog> The change log defines two change sets, which are executed in order, in separate transactions: The first change set defines a single query, which creates a node, with a Sentence label and a simple textual property called text . The second change set defines a single Cypher query as well, which finds the node pattern and updates the text property accordingly. If the Cypher syntax looks unfamiliar, feel free to follow this official tutorial . Info The location of this file will be called CHANGELOG_FILE throughout the rest of the tutorial. Note Contrary to Liquibase, Liquigraph only supports XML for defining change logs. Connection URI \u2693 To keep things simple, we will assume a standalone Neo4j server is running on your machine, via Neo4j Desktop or Docker for instance. The connection URI will be jdbc:neo4j:bolt://localhost , username neo4j and the password changeme . Depending on Neo4j versions, Neo4j server typology and Liquigraph client, connection URI can vary greatly. The configuration is covered in much greater details in the reference documentation . Configuration \u2693 Add the following dependencies to your POM file: Liquigraph 4.x <dependency> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-spring-boot-starter </artifactId> <version> 4.0.3 </version> </dependency> <dependency> <groupId> org.neo4j </groupId> <!-- change this to neo4j-jdbc-http for HTTP connections to Neo4j --> <artifactId> neo4j-jdbc-bolt </artifactId> <version> 4.0.1 </version> <scope> runtime </scope> </dependency> Liquigraph 3.x <dependency> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-spring-boot-starter </artifactId> <version> 3.1.2 </version> </dependency> <dependency> <groupId> org.neo4j </groupId> <!-- change this to neo4j-jdbc-http for HTTP connections to Neo4j --> <artifactId> neo4j-jdbc-bolt </artifactId> <version> 3.5.2 </version> <scope> runtime </scope> </dependency> You also need to configure your application with the Neo4j connection settings required by Liquigraph (in src/main/resources/application.properties for instance): spring.datasource.url = jdbc:neo4j:bolt://localhost spring.datasource.driver-class-name = org.neo4j.jdbc.bolt.BoltDriver spring.datasource.username = neo4j spring.datasource.password = changeme Run \u2693 Caution The \"dry run\" mode is currently not supported by the Spring Boot starter, contrary to the CLI and Maven plugin . Note CHANGELOG_FILE should be stored in src/main/resources/db/liquigraph/changelog.xml for the example to work. You just need to run: mvn spring-boot:run You can then check the data has been added in Neo4j Browser with the following Cypher query: MATCH ( sentence : Sentence ) RETURN sentence . text AS text The result should be \"Hello world!\". You can re-run the same Liquigraph command several times and observe that the graph remains unchanged. In other words, the following Cypher query: MATCH ( sentence : Sentence ) RETURN COUNT ( sentence ) ... should indeed always return 1. Good to know If you ever run a less specific Cypher query such as MATCH (n) RETURN n , you will see that more node and relationships are returned. This is normal: Liquigraph persists the change log history in the same database. The change log history graph structure is covered in much more details in the reference documentation .","title":"Spring Boot"},{"location":"quickstart/spring-boot/#spring-boot","text":"Liquigraph provides a Spring Boot starter. It is a good fit if your Spring Boot application owns (well-identified parts of) the data in Neo4j.","title":"Spring Boot"},{"location":"quickstart/spring-boot/#prerequisites","text":"Make sure a JDK is set up on the machine running the CLI . For Neo4j 3.x, the minimal JDK version is 8. For Neo4j 4.x, the minimal JDK version is 11.","title":"Prerequisites"},{"location":"quickstart/spring-boot/#download","text":"For this particular example, a simple Spring Boot application with a Maven build is assumed. Info You can bootstrap a project in a few clicks with Spring Initializr , the \"second best place on the Internet\" . You do not need to add any dependencies.","title":"Download"},{"location":"quickstart/spring-boot/#basic-concepts","text":"Liquigraph requires a single entry point, also known as a change log file. This file can include other change log files and/or define change set s. Every change set is executed in a separate transaction. They define at least 1 Cypher query. These Cypher queries define the data (or indices/constraints ) that will be created, modified or deleted from the target database. Caution Neo4j disallows mixing index/constraint with regular \"data\" operations within the same transaction. Such a transaction will always fail. As a consequence, index/constraint operations must be defined in separate Liquigraph change sets. Change sets are uniquely identified by their ID and author name. By default, they also are: incremental: they are allowed to run only once. immutable: their queries are not allowed to change. Learn how to change these defaults, and more, in the reference documentation .","title":"Basic concepts"},{"location":"quickstart/spring-boot/#first-migrations","text":"","title":"First migrations"},{"location":"quickstart/spring-boot/#change-log-creation","text":"Save the following change log file: 1 2 3 4 5 6 7 8 9 10 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <changelog xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation= \"https://www.liquigraph.org/schema/1.0/liquigraph.xsd\" > <changeset id= \"sentence-initialization\" author= \"florent-biville\" > <query> CREATE (n:Sentence {text:\"Hello monde!\"}) RETURN n </query> </changeset> <changeset id= \"sentence-correction\" author= \"florent-biville\" > <query> MATCH (n:Sentence {text:\"Hello monde!\"}) SET n.text=\"Hello world!\" RETURN n </query> </changeset> </changelog> The change log defines two change sets, which are executed in order, in separate transactions: The first change set defines a single query, which creates a node, with a Sentence label and a simple textual property called text . The second change set defines a single Cypher query as well, which finds the node pattern and updates the text property accordingly. If the Cypher syntax looks unfamiliar, feel free to follow this official tutorial . Info The location of this file will be called CHANGELOG_FILE throughout the rest of the tutorial. Note Contrary to Liquibase, Liquigraph only supports XML for defining change logs.","title":"Change log creation"},{"location":"quickstart/spring-boot/#connection-uri","text":"To keep things simple, we will assume a standalone Neo4j server is running on your machine, via Neo4j Desktop or Docker for instance. The connection URI will be jdbc:neo4j:bolt://localhost , username neo4j and the password changeme . Depending on Neo4j versions, Neo4j server typology and Liquigraph client, connection URI can vary greatly. The configuration is covered in much greater details in the reference documentation .","title":"Connection URI"},{"location":"quickstart/spring-boot/#configuration","text":"Add the following dependencies to your POM file: Liquigraph 4.x <dependency> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-spring-boot-starter </artifactId> <version> 4.0.3 </version> </dependency> <dependency> <groupId> org.neo4j </groupId> <!-- change this to neo4j-jdbc-http for HTTP connections to Neo4j --> <artifactId> neo4j-jdbc-bolt </artifactId> <version> 4.0.1 </version> <scope> runtime </scope> </dependency> Liquigraph 3.x <dependency> <groupId> org.liquigraph </groupId> <artifactId> liquigraph-spring-boot-starter </artifactId> <version> 3.1.2 </version> </dependency> <dependency> <groupId> org.neo4j </groupId> <!-- change this to neo4j-jdbc-http for HTTP connections to Neo4j --> <artifactId> neo4j-jdbc-bolt </artifactId> <version> 3.5.2 </version> <scope> runtime </scope> </dependency> You also need to configure your application with the Neo4j connection settings required by Liquigraph (in src/main/resources/application.properties for instance): spring.datasource.url = jdbc:neo4j:bolt://localhost spring.datasource.driver-class-name = org.neo4j.jdbc.bolt.BoltDriver spring.datasource.username = neo4j spring.datasource.password = changeme","title":"Configuration"},{"location":"quickstart/spring-boot/#run","text":"Caution The \"dry run\" mode is currently not supported by the Spring Boot starter, contrary to the CLI and Maven plugin . Note CHANGELOG_FILE should be stored in src/main/resources/db/liquigraph/changelog.xml for the example to work. You just need to run: mvn spring-boot:run You can then check the data has been added in Neo4j Browser with the following Cypher query: MATCH ( sentence : Sentence ) RETURN sentence . text AS text The result should be \"Hello world!\". You can re-run the same Liquigraph command several times and observe that the graph remains unchanged. In other words, the following Cypher query: MATCH ( sentence : Sentence ) RETURN COUNT ( sentence ) ... should indeed always return 1. Good to know If you ever run a less specific Cypher query such as MATCH (n) RETURN n , you will see that more node and relationships are returned. This is normal: Liquigraph persists the change log history in the same database. The change log history graph structure is covered in much more details in the reference documentation .","title":"Run"}]}